# -*- coding: utf-8 -*-
"""Dust_Risk.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jXshf0kCkOfhsYEy5_cxz4xsdPRWk5V0
"""

!pip install --upgrade xee

!pip install geemap

!pip install -U geemap

import ee
import xarray as xr
import geemap

ee.Authenticate()
ee.Initialize(
    project = 'ee-my-marv',
     opt_url='https://earthengine-highvolume.googleapis.com'
)

start_date = ee.Date('2020')
end_Date = ee.Date('2021')
time_diff = ee.Number(end_Date.difference(start_date, 'month')).round()
month_list = ee.List.sequence(0, time_diff.subtract(1)).map(lambda x : start_date.advance(x, 'month'))
month_list

import geemap

map = geemap.Map()
map

geometry = map.draw_last_feature.geometry()
geometry

aod = (
    ee.ImageCollection("MODIS/061/MCD19A2_GRANULES")
    .filterDate(start_date, end_Date)
    .select(['Optical_Depth_055'],['aod'])
    .filter(ee.Filter.eq('SATELLITE','T'))
    .filterBounds(geometry)

)

aod.limit(20)

#creating a list of months
def monthly(date, col):
  start_date = ee.Date(date)
  end_date =start_date.advance(1, 'month')
  col_img = col.filter(ee.Filter.date(start_date, end_date)).mean()
  col_size = ee.Number(col_img.bandNames().size())
  return col_img.set('system:time_start', start_date.millis()).set('bandsize', col_size)

#monthly aod
monthly_aod = ee.ImageCollection(
    month_list.map(lambda x : monthly(x, aod))
)

monthly_aod

terra =  (
    ee.ImageCollection("IDAHO_EPSCOR/TERRACLIMATE")
    .filterDate(start_date, end_Date)
    .filterBounds(geometry)
    .select('pr','soil', 'vs', 'tmmn', 'tmmx')
)
terra

#monthly terra
monthly_terra = ee.ImageCollection(
    month_list.map(lambda x : monthly(x, terra))
)
monthly_terra

ndvi = (
    ee.ImageCollection("MODIS/MOD09GA_006_NDVI")
    .filterDate(start_date, end_Date)
    .filterBounds(geometry)
    .select(['NDVI'], ['ndvi'])
)
ndvi

#monthly ndvi
monthly_ndvi = (ee.ImageCollection(month_list.map(
    lambda x : monthly(x, ndvi)
)))
monthly_ndvi

#combining all the variables into a single collection
collection = monthly_aod.combine(monthly_terra).combine(monthly_ndvi)
collection

#opening the collection using xarray to work with python directly
ds = xr.open_dataset(
    collection,
    engine = 'ee',
    crs = 'EPSG: 4326',
    geometry = geometry,
    scale = 0.1
)
ds

ds = ds.sortby('time')* 1
ds

ds.aod.plot(
    x= 'lon',
    y = 'lat',
    col = 'time',
    col_wrap = 6,
    robust = True
)

#loading the water mask
mask = (
    ee.ImageCollection("MODIS/061/MCD12Q1")
    .filterDate(start_date, end_Date)
    .filterBounds(geometry)
    .select('LC_Type1')
    .mode().eq(17).Not().rename('water_mask')
)
mask

ds_mask = xr.open_dataset(
    mask,
    engine = 'ee',
    crs = 'EPSG:4326',
    geometry =geometry,
    scale = 0.1
)

ds_mask

ds_mask = ds_mask.squeeze('time').drop_vars('time') * 1
ds_mask

ds_mask.water_mask.plot(
    x= 'lon',
    y = 'lat'
)

import numpy as np

#masking out the water pixels from the ds collection
ds = xr.where(ds_mask.water_mask == 0 , np.nan, ds)

ds.aod.plot(
    x = 'lon',
    y = 'lat',
    col = 'time',
    col_wrap = 6,
    robust = True

)

#creating a new variable dust
#dust occurs in areas where aod >= 0.5
ds['Dust'] = ((ds.aod * 0.001) >= 0.5).astype(int)
ds

ds.Dust.plot(
    x = 'lon',
    y= 'lat',
    col = 'time',
    col_wrap = 6,
    robust = True
)

#importing machine learning modules
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, roc_auc_score, roc_curve
from sklearn.linear_model import LogisticRegression

#convert the ds to a dataframe
df = ds.to_dataframe().dropna()
df

#train and test variable
X = df[['ndvi', 'vs', 'soil', 'tmmn', 'tmmx', 'pr']]
y = df[['Dust']]

#splitting training and testing variables
X_train,X_test, y_train, y_test = train_test_split(X, y , test_size = 0.2, random_state= 42)

#model fitting
model = LogisticRegression(class_weight="balanced",max_iter= 1000)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)
y_proba = model.predict_proba(X_test)

y_score = y_proba[:,1]
y_score.shape

#classification report
report = classification_report(y_test, y_pred)
print(report)

#compute the roc AREA UNDER THE CURVE
roc_score = roc_auc_score(y_test, y_score)
print(f"roc_auc_score: {roc_score:.2f}")

import matplotlib.pyplot as plt

#Compute False Positive Rate, True Positive Rate, and thresholds
fpr, tpr, threshold = roc_curve(y_test, y_score)
#plot the ROC CURVE
plt.figure()
plt.plot(fpr, tpr, label=f"Roc Curve (AUC = {roc_score:.3f})")
plt.plot([0,1], [0,1], linestyle= "--", label='Random Classifier')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate(Recall)")
plt.title("Roc Curve")
plt.legend()
plt.show()

df['risk'] = model.predict_proba(df[['ndvi', 'vs', 'soil', 'tmmn', 'tmmx', 'pr']])[:,1]
df

dfx = df.to_xarray().sortby(['time', 'lon', 'lat'])
dfx

risk = (dfx.risk * 1000).mean(dim ='time')

risk.plot(
    x = 'lon',
    y= 'lat',
    robust = True
)
plt.title('Predicted Dust Risk')
plt.show()

plt.figure(figsize = (13, 10))


dfx.risk.plot(
    x= 'lon',
    y = 'lat',
    col = 'time',
    col_wrap = 6,
    robust = True

)

plt.show()
plt.tight_layout()